<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Dodge - Redmark Studio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
        }
        
        .game-header {
            text-align: center;
            margin-bottom: 15px;
        }
        
        .game-header h1 {
            color: #E63946;
            font-size: 1.8rem;
            margin-bottom: 10px;
        }
        
        .score-display {
            display: flex;
            gap: 25px;
            justify-content: center;
            color: #B0B0B0;
            font-size: 1rem;
        }
        
        .score-display span {
            color: #E63946;
            font-weight: bold;
        }
        
        #gameCanvas {
            border: 3px solid #E63946;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(230, 57, 70, 0.3);
        }
        
        .controls {
            margin-top: 15px;
            color: #666;
            font-size: 0.85rem;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 10, 0.95);
            padding: 35px 50px;
            border-radius: 12px;
            border: 2px solid #E63946;
            text-align: center;
            display: none;
        }
        
        .game-over h2 {
            color: #E63946;
            font-size: 2.2rem;
            margin-bottom: 12px;
        }
        
        .game-over p {
            color: #fff;
            font-size: 1.1rem;
            margin-bottom: 20px;
        }
        
        .restart-btn {
            background: #E63946;
            color: white;
            border: none;
            padding: 10px 30px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .restart-btn:hover {
            background: #FF4D5E;
            box-shadow: 0 0 20px rgba(230, 57, 70, 0.5);
        }
        
        .mobile-controls {
            display: none;
            margin-top: 15px;
            gap: 8px;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(230, 57, 70, 0.2);
            border: 2px solid #E63946;
            border-radius: 10px;
            color: #E63946;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            user-select: none;
        }
        
        .control-btn:active {
            background: #E63946;
            color: white;
        }
        
        .control-row {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        @media (max-width: 600px) {
            .mobile-controls {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            
            #gameCanvas {
                width: 100%;
                max-width: 360px;
            }
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1>◆ Space Dodge</h1>
        <div class="score-display">
            <div>Score: <span id="score">0</span></div>
            <div>High: <span id="highScore">0</span></div>
        </div>
    </div>
    
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    
    <div class="controls">
        Use Arrow Keys or WASD to Move | Dodge the Asteroids!
    </div>
    
    <div class="mobile-controls">
        <div class="control-row">
            <button class="control-btn" onmousedown="setDirection('LEFT')" ontouchstart="setDirection('LEFT')">◀</button>
            <button class="control-btn" onmousedown="setDirection('DOWN')" ontouchstart="setDirection('DOWN')">▼</button>
            <button class="control-btn" onmousedown="setDirection('UP')" ontouchstart="setDirection('UP')">▲</button>
            <button class="control-btn" onmousedown="setDirection('RIGHT')" ontouchstart="setDirection('RIGHT')">▶</button>
        </div>
    </div>
    
    <div class="game-over" id="gameOver">
        <h2>Game Over!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button class="restart-btn" onclick="restartGame()">Play Again</button>
    </div>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('highScore');
        const finalScoreEl = document.getElementById('finalScore');
        const gameOverEl = document.getElementById('gameOver');
        
        let player = {};
        let asteroids = [];
        let stars = [];
        let score = 0;
        let highScore = localStorage.getItem('spaceDodgeHighScore') || 0;
        let gameLoop = null;
        let isGameOver = false;
        let keys = {};
        let gameSpeed = 1;
        let asteroidSpawnRate = 60;
        let frameCount = 0;
        
        highScoreEl.textContent = highScore;
        
        // Create starfield background
        function createStars() {
            stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 2 + 0.5,
                    brightness: Math.random()
                });
            }
        }
        
        function initGame() {
            player = {
                x: canvas.width / 2,
                y: canvas.height - 80,
                width: 30,
                height: 30,
                speed: 6,
                color: '#E63946'
            };
            
            asteroids = [];
            score = 0;
            gameSpeed = 1;
            asteroidSpawnRate = 60;
            frameCount = 0;
            isGameOver = false;
            
            scoreEl.textContent = score;
            gameOverEl.style.display = 'none';
            
            createStars();
            
            if (gameLoop) cancelAnimationFrame(gameLoop);
            gameLoop = requestAnimationFrame(update);
        }
        
        function createAsteroid() {
            const size = Math.random() * 30 + 20;
            asteroids.push({
                x: Math.random() * (canvas.width - size),
                y: -size,
                width: size,
                height: size,
                speed: (Math.random() * 2 + 3) * gameSpeed,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 0.1,
                vertices: generateAsteroidVertices()
            });
        }
        
        function generateAsteroidVertices() {
            const vertices = [];
            const numVertices = 8;
            for (let i = 0; i < numVertices; i++) {
                const angle = (i / numVertices) * Math.PI * 2;
                const radius = 0.5 + Math.random() * 0.3;
                vertices.push({ angle, radius });
            }
            return vertices;
        }
        
        function drawStars() {
            stars.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + star.brightness * 0.5})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
                
                star.y += star.speed * gameSpeed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
        }
        
        function drawPlayer() {
            // Ship body
            ctx.fillStyle = player.color;
            ctx.shadowColor = '#E63946';
            ctx.shadowBlur = 15;
            
            ctx.beginPath();
            ctx.moveTo(player.x, player.y - player.height / 2);
            ctx.lineTo(player.x - player.width / 2, player.y + player.height / 2);
            ctx.lineTo(player.x + player.width / 2, player.y + player.height / 2);
            ctx.closePath();
            ctx.fill();
            
            // Engine glow
            ctx.fillStyle = '#FF4D5E';
            ctx.beginPath();
            ctx.moveTo(player.x - 8, player.y + player.height / 2);
            ctx.lineTo(player.x + 8, player.y + player.height / 2);
            ctx.lineTo(player.x, player.y + player.height / 2 + 10 + Math.random() * 5);
            ctx.closePath();
            ctx.fill();
            
            ctx.shadowBlur = 0;
        }
        
        function drawAsteroid(asteroid) {
            ctx.save();
            ctx.translate(asteroid.x + asteroid.width / 2, asteroid.y + asteroid.height / 2);
            ctx.rotate(asteroid.rotation);
            
            // Draw asteroid
            ctx.fillStyle = '#555';
            ctx.strokeStyle = '#777';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            asteroid.vertices.forEach((v, i) => {
                const x = Math.cos(v.angle) * asteroid.width / 2 * v.radius;
                const y = Math.sin(v.angle) * asteroid.height / 2 * v.radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
        }
        
        function checkCollision(rect1, rect2) {
            // Simple collision with some padding
            const padding = 5;
            return rect1.x + padding < rect2.x + rect2.width - padding &&
                   rect1.x + rect1.width - padding > rect2.x + padding &&
                   rect1.y + padding < rect2.y + rect2.height - padding &&
                   rect1.y + rect1.height - padding > rect2.y + padding;
        }
        
        function update() {
            if (isGameOver) return;
            
            frameCount++;
            
            // Update score
            score += Math.floor(gameSpeed);
            scoreEl.textContent = score;
            
            // Increase difficulty
            if (frameCount % 500 === 0) {
                gameSpeed += 0.1;
                asteroidSpawnRate = Math.max(20, asteroidSpawnRate - 5);
            }
            
            // Player movement
            if (keys['ArrowLeft'] || keys['KeyA']) {
                player.x -= player.speed;
            }
            if (keys['ArrowRight'] || keys['KeyD']) {
                player.x += player.speed;
            }
            if (keys['ArrowUp'] || keys['KeyW']) {
                player.y -= player.speed;
            }
            if (keys['ArrowDown'] || keys['KeyS']) {
                player.y += player.speed;
            }
            
            // Keep player in bounds
            player.x = Math.max(player.width / 2, Math.min(canvas.width - player.width / 2, player.x));
            player.y = Math.max(player.height / 2, Math.min(canvas.height - player.height / 2, player.y));
            
            // Spawn asteroids
            if (frameCount % asteroidSpawnRate === 0) {
                createAsteroid();
            }
            
            // Update asteroids
            asteroids.forEach((asteroid, index) => {
                asteroid.y += asteroid.speed;
                asteroid.rotation += asteroid.rotationSpeed;
                
                // Remove off-screen asteroids
                if (asteroid.y > canvas.height + asteroid.height) {
                    asteroids.splice(index, 1);
                }
                
                // Check collision
                if (checkCollision(player, asteroid)) {
                    endGame();
                }
            });
            
            // Draw everything
            draw();
            
            if (!isGameOver) {
                gameLoop = requestAnimationFrame(update);
            }
        }
        
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars
            drawStars();
            
            // Draw asteroids
            asteroids.forEach(drawAsteroid);
            
            // Draw player
            drawPlayer();
        }
        
        function endGame() {
            isGameOver = true;
            cancelAnimationFrame(gameLoop);
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('spaceDodgeHighScore', highScore);
                highScoreEl.textContent = highScore;
            }
            
            finalScoreEl.textContent = score;
            gameOverEl.style.display = 'block';
        }
        
        function restartGame() {
            initGame();
        }
        
        function setDirection(dir) {
            keys[dir] = true;
            return false;
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            if (isGameOver && (e.code === 'Space' || e.code === 'Enter')) {
                restartGame();
            }
            
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // Touch controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            
            // Check if game over
            if (isGameOver) {
                restartGame();
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const diffX = touch.clientX - touchStartX;
            const diffY = touch.clientY - touchStartY;
            
            // Move player based on touch drag
            if (Math.abs(diffX) > 10) {
                player.x += diffX > 0 ? player.speed : -player.speed;
            }
            if (Math.abs(diffY) > 10) {
                player.y += diffY > 0 ? player.speed : -player.speed;
            }
            
            // Keep player in bounds
            player.x = Math.max(player.width / 2, Math.min(canvas.width - player.width / 2, player.x));
            player.y = Math.max(player.height / 2, Math.min(canvas.height - player.height / 2, player.y));
            
            // Update start position for continuous movement
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        });
        
        // Start the game
        initGame();
    </script>
</body>
</html>
